// Generated by CoffeeScript 1.12.4
var Decrypter, Encrypter, Transform, crypto,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

crypto = require('crypto');

Transform = require('stream').Transform;

Encrypter = (function(superClass) {
  extend(Encrypter, superClass);

  function Encrypter(options) {
    Encrypter.__super__.constructor.call(this, options);
    this.header_written = false;
    this.algorithm = options.algorithm;
    if (this.algorithm == null) {
      this.algorithm = 'AES-256-CBC';
    }
    this.key_length = options.key_length;
    if (this.key_length == null) {
      this.key_length = 256;
    }
    this.public_key = options.public_key;
    this.key = options.key;
    if (!this.public_key) {
      throw new Error("Missing public key");
    }
  }

  Encrypter.prototype.getRandomBytes = function(length) {
    return crypto.randomBytes(length);
  };

  Encrypter.prototype.initialize = function() {
    var encrypted_key, header, index, iv, key, keys, self;
    self = this;
    keys = this.getRandomBytes(16 + this.key_length / 8);
    iv = keys.slice(0, 16);
    key = keys.slice(16);
    this.cipher = crypto.createCipheriv(this.algorithm, key, iv);
    this.cipher.on('data', function(buffer) {
      return self.push(buffer);
    });
    this.cipher.on('error', function(error) {
      return logger.debug('cipher error', error);
    });
    encrypted_key = crypto.publicEncrypt(this.public_key, key);
    header = Buffer.alloc(4096);
    index = 0;
    index = header.writeInt16LE(0, index);
    index = header.writeInt16LE(this.algorithm.length, index);
    index = index + header.write(this.algorithm, index, 'latin1');
    index = header.writeInt16LE(encrypted_key.length, index);
    header.fill(encrypted_key, index, index + encrypted_key.length);
    index = index + encrypted_key.length;
    index = header.writeInt16LE(iv.length, index);
    header.fill(iv, index, index + iv.length);
    index = index + iv.length;
    header.writeInt16LE(index, 0);
    this.push(header.slice(0, index));
    return this.header_written = true;
  };

  Encrypter.prototype._transform = function(chunk, encoding, callback) {
    var result;
    if (!this.header_written) {
      this.initialize();
    }
    return result = this.cipher.write(chunk, encoding, function() {
      return callback();
    });
  };

  Encrypter.prototype._flush = function(callback) {
    return this.cipher.end(function() {
      return callback();
    });
  };

  return Encrypter;

})(Transform);

Decrypter = (function(superClass) {
  extend(Decrypter, superClass);

  function Decrypter(options) {
    Decrypter.__super__.constructor.call(this, options);
    this.header_complete = false;
    this.key = options.key;
    this.header = Buffer.alloc(4096);
    this.header_size = 0;
    this.header_index = 0;
  }

  Decrypter.prototype.unpackHeader = function() {
    var algorithm_size, encrypted_key, encrypted_key_size, index, iv_size, self;
    self = this;
    index = 0;
    this.header_size = this.header.readInt16LE(index);
    index = index + 2;
    algorithm_size = this.header.readInt16LE(index);
    index = index + 2;
    this.algorithm = this.header.slice(index, index + algorithm_size).toString('latin1');
    index = index + algorithm_size;
    encrypted_key_size = this.header.readInt16LE(index);
    index = index + 2;
    encrypted_key = this.header.slice(index, index + encrypted_key_size);
    index = index + encrypted_key_size;
    iv_size = this.header.readInt16LE(index);
    index = index + 2;
    this.iv = this.header.slice(index, index + iv_size);
    index = index + iv_size;
    this.key = crypto.privateDecrypt(this.key, encrypted_key);
    this.cipher = crypto.createDecipheriv(this.algorithm, this.key, this.iv);
    this.cipher.on('data', function(buffer) {
      return self.push(buffer);
    });
    this.cipher.on('error', function(error) {
      return logger.debug('cipher error', error);
    });
    return this.header_complete = true;
  };

  Decrypter.prototype._transform = function(chunk, encoding, callback) {
    var header_buffer, result;
    chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
    if (!this.header_complete) {
      this.header.fill(chunk, this.header_index);
      this.header_index = this.header_index + chunk.length;
      if (this.header_index >= 2) {
        this.header_size = this.header.readInt16LE(0);
      } else {
        return callback();
      }
      if ((this.header_size == null) || this.header_index < this.header_size) {
        return callback();
      }
      header_buffer = this.header.slice(0, this.header_size);
      chunk = chunk.slice(chunk.length - (this.header_index - this.header_size));
      this.header = header_buffer;
      this.unpackHeader();
    }
    return result = this.cipher.write(chunk, encoding, function() {
      return callback();
    });
  };

  Decrypter.prototype._flush = function(callback) {
    return this.cipher.end(function() {
      return callback();
    });
  };

  return Decrypter;

})(Transform);

module.exports = {
  Encrypter: Encrypter,
  Decrypter: Decrypter
};
